TCP 三次握手 四次挥手

tcp在传输层

tcp：

![image-20230208155914885](http://bijioss.donggei.top/image-20230208155914885.png)

tcp报文：

![image-20230206165224862](http://bijioss.donggei.top/image-20230206165224862.png)

三次握手：

![image-20230209112029330](http://bijioss.donggei.top/image-20230209112029330.png)

tcp 其中也涉及到了状态的切换 利用了这种状态保证了建立连接和断开连接的逻辑

> 两次握手不可？
>
> 第一个解释:
>
> 这个问题的本质是, 信道不可靠, 但是通信双发需要就某个问题达成一致. 而要解决这个问题,  无论你在消息中包含什么信息, 三次通信是理论上的最小值
>
> 如果 A主动发起的请求。
>
> 2次只能保证A检验了发送和接受的能力
>
> B并不知道自己的消息是否成功发送了
>
> 第二个解释：
>
> 为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误
>
> 如果client发的SYN请求 在网络中长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。但是后面serve接收到了，假设不采用“三次握手”，那么只要server发出确认，新的连接就建立，server却以为新的运输连接已经建立，并一直等待client发来数据。

四次挥手：

![image-20230209112116477](http://bijioss.donggei.top/image-20230209112116477.png)

> 为什么不是3次？
>
> 中间可能会有数据的传输
>
> client发送FIN后 serve可能还有数据等待传输。
>
> ------------------------------------------------------------------------------
>
> 这里特别需要主要的就是TIME_WAIT这个状态了，就是要理解，为什么客户端发送 ACK 之后不直接关闭，而是要等一阵子才关闭。这其中的原因就是，要确保服务器是否已经收到了我们的 ACK  报文，如果没有收到的话，服务器会重新发 FIN 报文给客户端，客户端再次收到 ACK 报文之后，就知道之前的 ACK 报文丢失了，然后再次发送  ACK 报文。
> 至于 TIME_WAIT 持续的时间至少是一个报文的来回时间。一般会设置一个计时，如果过了这个计时没有再次收到 FIN 报文，则代表对方成功就是 ACK 报文，此时处于 CLOSED 状态。

