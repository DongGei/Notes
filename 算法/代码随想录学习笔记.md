# [代码随想录](https://programmercarl.com/)学习笔记

结合自身需求，主要偏重java

[学习地址](https://github.com/youngyangyang04/leetcode-master)



## 一.数组

### 1.理论

+ **数组是存放在连续内存空间上的相同类型数据的集合。**

- **数组下标都是从0开始的。**
- **数组内存空间的地址是连续的。**
- java内存图：

![算法通关数组3](https://gitee.com/dong2645981073/picture-summary/raw/master//image/20201214111631844.png)

### 2. 二分查找
二分查找也称折半查找（Binary Search）,是一个高效的查找算法。
```
首先，假设数组中的元素是按升序排列；

将数组中间位置记录的元素值与要查找的元素值比较，如果两者相等，则查找成功；

否则利用中间位置的记录将数组分成前、后两个子数组；

如果中间位置记录的元素值大于要查找元素值，则进一步查找前一子数组，否则进一步查找后一子数组。

重复以上过程，直到找到满足条件的记录，使查找成功，或直到子表不存在为止，此时查找不成功。


```
在java的集合对象中也提供了二分查找的算法，如下面的java api接口：

如果返回值>=0 说明存在key,否则不存在该key(不存在返回-(low + 1);)

```java
java.util.Arrays.binarySearch(java.lang.Object,java.lang.Object,java.util.Comparator)     
java.util.Arrays.binarySearch(java.lang.Object[], java.lang.Object)
```

重点：*<u>**折半查找要求查询的数组的元素是      1.有序排列的  2.无重复的 **。</u>*

```java
public class t_binarySearch {
    public static void main(String[] args) {
       int[] a  = new int[]{10,11,23,33,45,50,60,65};
        int i = Arrays.binarySearch(a, 20);
        System.out.println("索引下标是"+i);
        //索引下标是-3
    }
}
public static void main(String[] args) {
       int[] a  = new int[]{10,11,23,33,45,50,60,65};
        int i = Arrays.binarySearch(a, 11);
        System.out.println("索引下标是"+i);
    	//索引下标是1
    }
```



### 3.移除元素

**双指针法（快慢指针法）在数组和链表的操作中是非常常见的，很多考察数组、链表、字符串等操作的面试题，都使用双指针法。**

本题的理解：快指针是在前面进行预先处理的，慢指针保存我们最后需要的结果

```java
class Solution {
    public int removeElement(int[] nums, int val) {

        // 快慢指针
        int fastIndex = 0;
        int slowIndex;
        for (slowIndex = 0; fastIndex < nums.length; fastIndex++) 		{
            if (nums[fastIndex] != val) {
                nums[slowIndex] = nums[fastIndex];
                slowIndex++;
            }
        }
        return slowIndex;

    }
}
```

例题1：[283. 移动零](https://leetcode-cn.com/problems/move-zeroes/)

```java
class Solution {
    public void moveZeroes(int[] nums) {
        int fastIndex;
        int slowIndex=0;
        int c=0;
        for(fastIndex = 0; fastIndex<nums.length;fastIndex++){
            if(nums[fastIndex] != 0){
            nums[slowIndex]=nums[fastIndex];
            slowIndex++;
            c++;
            }
        }
        for(int i=c;i<nums.length;i++){
            nums[i]=0;
        }
        System.out.print(nums);
    }
}
```

先移动不是0的元素在前面，后面的补零即可。

### 4.[ 有序数组的平方](https://leetcode-cn.com/problems/squares-of-a-sorted-array/)

给你一个按 **非递减顺序** 排序的整数数组 `nums`，返回 **每个数字的平方** 组成的新数组，要求也按 **非递减顺序** 排序。

解读：给你一个递增序列，返回每个元素平方后的递增序列。

java.api暴力解答：

```java
import java.util.Arrays;
class Solution {
    public int[] sortedSquares(int[] nums) {
        int n=nums.length;
        for(int i=0;i<n;i++){
            nums[i]=nums[i]*nums[i];
        }
        Arrays.sort(nums);
       return nums;
    }
}
```

![image-20220115112659380](C:\Users\DONG\AppData\Roaming\Typora\typora-user-images\image-20220115112659380.png)

观察最大值每次存在左右两端。

![image-20220115112915801](https://gitee.com/dong2645981073/picture-summary/raw/master//image/image-20220115112915801.png)

使用双指针

```
import java.util.Arrays;
class Solution {
    public int[] sortedSquares(int[] nums) {
        int right=nums.length-1;
        int left=0;
        //每次比较两端的值 放入数组的最后
        int[] ints=new int[nums.length];
        int wz=nums.length;
        while(left<=right){
            if(nums[left]*nums[left]>nums[right]*nums[right]){
                ints[--wz]=nums[left]*nums[left];
                left++;
            }else{
                ints[--wz]=nums[right]*nums[right];
                right--;
            }
        }
        return ints;
    }
}
```

### 5.[长度最小的子数组](https://leetcode-cn.com/problems/minimum-size-subarray-sum/)

给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。

示例：

输入：s = 7, nums = [2,3,1,2,4,3] 输出：2 解释：子数组 [4,3] 是该条件下的长度最小的子数组。

<u>无论是暴力还是使用“滑动窗口”（双指针的方法）都是为了确定子序列的起始位置和结束位置</u>

暴力：

```java
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        int qswz=0;
        int jswz=0;
        int sum=0;
        int jg=Integer.MAX_VALUE;
        for(;qswz<nums.length;qswz++){
            sum=0;
            for(jswz=qswz;jswz<nums.length;jswz++){
                sum+=nums[jswz];
                while(sum>=target){
                    jg=Math.min((jswz-qswz+1),jg);
                    break;
                }
            }
        }
        return jg == Integer.MAX_VALUE ? 0 : jg;
    
    }
}
```

就是从每一个位置开始先后计算到满足条件后跳出。

所谓滑动窗口，**就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果**。

```java
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        int qswz=0;
        int jswz=0;
        int sum=0;
        int jg=Integer.MAX_VALUE;
        for(jswz=0;jswz<nums.length;jswz++){
            sum+=nums[jswz];
           while(sum>=target){
               int l=jswz-qswz+1;
               jg=Math.min(l,jg);
               sum-=nums[qswz];
               qswz++;
           }
        }
        return jg == Integer.MAX_VALUE ? 0 : jg;
    }
}
```

理解：当子序列和大于等于 值 时就减去前面的，增加起始位置，子序列和小于时就加后面的元素，增加结束位置。一个循环解决问题。

### 6.[螺旋矩阵 II](https://leetcode-cn.com/problems/spiral-matrix-ii/)

n=3，4和5 为例.

![image-20220115203028062](https://gitee.com/dong2645981073/picture-summary/raw/master//image/image-20220115203028062.png)

![image-20220115203035670](https://gitee.com/dong2645981073/picture-summary/raw/master//image/image-20220115203035670.png)![image-20220115205313285](https://gitee.com/dong2645981073/picture-summary/raw/master//image/image-20220115205313285.png)

本题在于找到合适的模拟过程；

分析：

+ 一圈一圈的转 转一圈减少2行和两列；n=3，转1圈，n=4，5，转2圈；

圈数=n/2；

+ n=5，每一行一列走4个 碰到拐角停止 每次走n-1个，走4次。刚好走完一圈。

+ 第二圈 改变起始位置，每次走n-3个 如果n-3=0 说明到最后一个了

+ 第三圈 改变起始位置，每次走n-5个 如果n-5=0 说明到最后一个了 <0 说明走完了

  

```java
class Solution {
    public int[][] generateMatrix(int n) {
        int[][] ints =new int[n][n];
        int num=1;
        int qs=n/2;
        int startX=0;
        int startY=0;
        int zodeshu=n-1;
        for(int i =0;i<qs;i++){
            for(int j=0;j<zodeshu;j++){
                ints[startX][startY+j]=num++;
            }
            for(int z=0;z<zodeshu;z++){
                ints[startX+z][startY+zodeshu]=num++;
            }
            for(int z=0;z<zodeshu;z++){
                ints[startX+zodeshu][startY+zodeshu-z]=num++;
            }
            for(int z=0;z<zodeshu;z++){
                ints[startX+zodeshu-z][startY]=num++;
            }

        zodeshu=zodeshu-2;
        startX++;
        startY++;
        }
        if(n%2 == 1){
            ints[n/2][n/2]=num;
        }
        return ints;
    }
}

```

与教程中大致相同。

## 二.链表

### 1.理论

+ 单链表

+ 双链表

+ 循环链表

+ 虚拟头结点

  链表的一大问题就是操作当前节点必须要找前一个节点才能操作。这就造成了，头结点的尴尬，因为头结点没有前一个节点了。

  

  

  

  因为本次针对Java来学习。java中有大量的链表API 因此 有一部分略过。

### 2.[反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)

双指针法 与 递归法思想一致

```java
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode pre = null;
        ListNode cur = head;
        while (cur!=null){
            ListNode temp=cur.next;
            cur.next=pre;
            pre=cur;
            cur =temp;
        }
        return pre;
    }
}
```

temp 保存cur后面的 防止改动cur指针后丢失后面的。

### 3.[删除链表的倒数第 N 个结点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)

```java
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode dummy =new ListNode(0,head);
        ListNode cur= head;
        ListNode pre = dummy;
        if(head.next==null && n==1){
            return null;
        }   
        for(int i=0; i<n;i++){
            cur=cur.next;
        }
        while(cur!=null){
        
            cur=cur.next;
            pre=pre.next;
        }
        pre.next=pre.next.next;
        return dummy.next;
    }
}
```

双指针的经典应用，如果要删除倒数第n个节点，让fast移动n步，然后让fast和slow同时移动，直到fast指向链表末尾。删掉slow所指向的节点就可以了。

梳理：

+ 控制好 pre 和 cur 保持的距离和n的关系，确保能删除倒是第n的

+ 考虑 使用虚拟头结点 可能会删除真头结点
+ 考虑 只有一个结点并要删除

### 4.[链表相交](https://leetcode-cn.com/problems/intersection-of-two-linked-lists-lcci/)

 ```java
 public class Solution {
     public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
         int la=0;
         int lb=0;
         ListNode re=null;
         ListNode pa=headA;
         ListNode pb=headB;
         while(pa!=null){
             pa=pa.next;
             la++;
         }
         while(pb!=null){
             pb=pb.next;
             lb++;
         }
         if(la>lb){
         int cha=la-lb;
          pa=headA;
          pb=headB;
         while(cha-->0){
             pa=pa.next;
         }
         while(pb!=pa){
             pb=pb.next;
             pa=pa.next; 
         }
         re=pa;
         }
         if(la<=lb){
         int cha=lb-la;
          pa=headA;
          pb=headB;
         while(cha-->0){
             pb=pb.next;
         }
         while(pb!=pa){
             pb=pb.next;
             pa=pa.next;  
         }
         re=pa;
         }
         return re;
     }
 }
 ```

梳理：

+ 主要可以想到后面的如果想交个数总是相同的；

  根据个数的差值来来跳过一部分， 寻找后面可能相交的

### 5.[环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)

先使用快慢指针来确定是不是有环，和确定相遇的位置。再使用相遇位置和起始位置确定环的入口。 

```java
public class Solution {
    public ListNode detectCycle(ListNode head) {
        ListNode slow = head;
        ListNode fast = head;
        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
            if (slow == fast) {// 有环
                ListNode index1 = fast;
                ListNode index2 = head;
                // 两个指针，从头结点和相遇结点，各走一步，直到相遇，相遇点即为环入口
                while (index1 != index2) {
                    index1 = index1.next;
                    index2 = index2.next;
                }
                return index1;
            }
        }
        return null;
    }
}
```

## 三.哈希表

### 1.理论

### 2. [有效的字母异位词](https://leetcode-cn.com/problems/valid-anagram/)

```java
class Solution {
    public boolean isAnagram(String s, String t) {
		  boolean bool=true;
	        int[] r =new int[26];
	        char[] ss=s.toCharArray();
	        char[] tt=t.toCharArray();
	        for (int i = 0; i < tt.length; i++) {
				char c = tt[i];
				r[c-'a']++;
			}
	        for (int i = 0; i < ss.length; i++) {
				char c = ss[i];
				r[c-'a']--;
			}
	        for (int i = 0; i < r.length; i++) {
				if (r[i]!=0) {
					bool=false;
				}
			}
	        return bool;
	    }
}
```

哈希的应用:把 每一个字母 对应  数组中每一个位置。位置是数是字母的个数。

时间复杂度降到了O(n)。 

### 3.[两个数组的交集](https://leetcode-cn.com/problems/intersection-of-two-arrays/)

计算数组的交集 数组里有重复的元素， 放入hashset 去除重复元素 然后遍历第二个数组 是否包含在set里 如果包含就加入结果数组中；

实际写代码调试的时候发现 两个数组都要去除重复元素，因为在确定返回数组的个数时，遍历第二个数组 是否包含在set里时会重复计算相同元素

```java
class Solution {
  public int[] intersection(int[] nums1, int[] nums2) {
		int[] re =null;
		int count=0;
		
		Set<Integer> set1 = new HashSet<Integer>();
		Set<Integer> set2 = new HashSet<Integer>();
		
        for (int i = 0; i < nums1.length; i++) {
			set1.add(nums1[i]);
		}
        for (int i = 0; i < nums2.length; i++) {
			set2.add(nums2[i]);
		}
        for (Integer i:set2) {
			if (set1.contains(i)) {
				count++;
			}
		}
        re=new int[count];
        count=0;
        for (Integer i:set2) {
			if (set1.contains(i)) {
				re[count]=i;
                count++;
			}
		} 
        return re;
    }
}
```

我的题解属于暴力算法 两个数组去重后 遍历两次，一次确定重复的个数，一个添加进放回的数组。

### 4.[快乐数](https://leetcode-cn.com/problems/happy-number/)

重点：题目中说了会 **无限循环**，那么也就是说**求和的过程中，sum会重复出现**

判断重复出现要使用set

```java
class Solution {
     public boolean isHappy(int n) {
	   Set<Integer> set = new HashSet<Integer>(); 
	   while(!set.contains(n)) {
            set.add(n);
            n= nextN(n);
		    if (n==1) {
			return true;
		    }   
	   }
	   return false;
	 }
	 
	 public int nextN(int n) {
		 int re=0;
		 while(n > 0) {
			 int a = n%10;
			 n=n/10;
			 re+=a*a;
		 }
	        return re;
	}
}
```

### 5.[两数之和](https://leetcode-cn.com/problems/two-sum/)

[242. 有效的字母异位词 (opens new window)](https://www.programmercarl.com/0242.有效的字母异位词.html)这道题目是用数组作为哈希表来解决哈希问题，[349. 两个数组的交集 (opens new window)](https://www.programmercarl.com/0349.两个数组的交集.html)这道题目是通过set作为哈希表来解决哈希问题。

本题呢，则要使用map，那么来看一下使用数组和set来做哈希法的局限。

- 数组的大小是受限制的，而且如果元素很少，而哈希值太大会造成内存空间的浪费。
- set是一个集合，里面放的元素只能是一个key，而两数之和这道题目，不仅要判断y是否存在而且还要记录y的下标位置，因为要返回x 和 y的下标。所以set 也不能用。

此时就要选择另一种数据结构：map ，map是一种key value的存储结构，可以用key保存数值，用value在保存数值所在的下标。

```java
class Solution {
     public int[] twoSum(int[] nums, int target) {
        int[] ints = new int[]{-1,-1};
        HashMap<Integer, Integer> hashMap = new HashMap<>();
        for (int i=0;i<nums.length;i++){
            int a=target-nums[i];
            if (hashMap.containsKey(a)){
              ints=new int[]{hashMap.get(a),i};
            }
            hashMap.put(nums[i],i);
        }
        return ints;
    }
}
```

两个数相加 符合条件的 一定是一个在前 一个在后，并且同一个元素不能使用两遍。所有要先判断前面是不是有需要的，没有的话再把它加进去，



我们想要的这两个数 在循环中会都会经过。前面的是加进去的，后面的确认。 两个数一前一后 后面的肯定很找到前面的。

### 6.[四数相加 II](https://leetcode-cn.com/problems/4sum-ii/)

```java
class Solution {
    public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {
		int re=0;
		HashMap<Integer, Integer> map1=new HashMap<Integer, Integer>();
		for (int i = 0; i < nums1.length; i++) {
			for (int j = 0; j < nums2.length; j++) {
				if (map1.containsKey(nums1[i]+nums2[j])) {
					map1.put(nums1[i]+nums2[j],map1.get(nums1[i]+nums2[j])+1);
				}else {
					map1.put(nums1[i]+nums2[j],1);
				}
				
			}
		}
		for (int i = 0; i < nums3.length; i++) {
			for (int j = 0; j < nums4.length; j++) {
				if (map1.containsKey(0-(nums3[i]+nums4[j]))) {
					re+=map1.get(0-(nums3[i]+nums4[j]));
				}
				
			}
		}
		return re;
    }
}
```

两重循环把两个数组 和 的所有可能值和个数 统计一遍。

再来两重循环 把剩余两个数组 和的所有可能的值 匹配一次

![image-20220119120339780](https://gitee.com/dong2645981073/picture-summary/raw/master//image/image-20220119120339780.png)

### 7.[赎金信](https://leetcode-cn.com/problems/ransom-note/)

```java
class Solution {
    public boolean canConstruct(String ransomNote, String magazine) {
        int[] arr =new int[26];
        for(char c :magazine.toCharArray()) {
        	arr[c-'a']++;
        }
        for(char c :ransomNote.toCharArray()) {
        	arr[c-'a']--;
        	
        }
        for (int i = 0; i < arr.length; i++) {
			if (arr[i]<0) {
				return false;
			}
		}
        return true ;
    }
}
```

与  2. [有效的字母异位词] 相似 利用数组作为哈希表来解决问题

arr[i]<0 时说明ransomnote里的字母在magazine没有或不够。

### 8.[三数之和](https://leetcode-cn.com/problems/3sum/)

 双指针法，使用的是map的包含方法。

如果使用双指针一定是可以排序的数组，排序后不影响结果的题目

两数之和 如果使用双指针，排序后索引改变，影响返回结果；

```java
public class LK015 {
	public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> result = new ArrayList<>();
        Arrays.sort(nums);

        for (int i = 0; i < nums.length; i++) {
            if (nums[i] > 0) {
            	//满足条件，说明后面的都是大于0的，相加不可能是0
                //这个if 可以省略
                return result;
            }

            if (i > 0 && nums[i] == nums[i - 1]) {
            	//如果它和前面的数一样。那么最后放回的值一样  可以跳过。主要是达到去重，完成题目要求；
                continue;
            }

            int left = i + 1;
            int right = nums.length - 1;
            while (right > left) {
                int sum = nums[i] + nums[left] + nums[right];
                if (sum > 0) {
                    right--;
                } else if (sum < 0) {
                    left++;
                } else {
                    result.add(Arrays.asList(nums[i], nums[left], nums[right]));
                    //去除重复
                    while (right > left && nums[right] == nums[right - 1]) right--;
                    while (right > left && nums[left] == nums[left + 1]) left++;
                    
                    right--; 
                    left++;
                }
            } 
        }
        return result;
    }
}

```

### 9.[四数之和](https://leetcode-cn.com/problems/4sum/)

![image-20220121193849422](https://gitee.com/dong2645981073/picture-summary/raw/master//image/image-20220121193849422.png)

```java
class Solution {
    public List<List<Integer>> fourSum(int[] nums, int target) {

		List<List<Integer>> list = new ArrayList<List<Integer>>();
        Arrays.sort(nums);
		 for (int i = 0; i < nums.length; i++) {
			if (i>0  && nums[i]== nums[i-1]) {
				 continue;
			}
			for (int j = i+1; j < nums.length; j++) {
				//j>i+1 第一个是需要的 如果后面还有是重复的
				if (j>i+1  && nums[j]==nums[j-1]) {
					continue;
				}
				int left=j+1;
				int rigth=nums.length-1;
				
				while(left<rigth) {
					int sum=nums[i]+nums[j]+nums[left]+nums[rigth];
					if (sum>target) {
						rigth--;
					}else if (sum<target) {
						left++;
					}else{
						list.add(Arrays.asList(nums[i],nums[j],nums[left],nums[rigth]));
						//这里记得写：left<rigth 
						while (left<rigth &&nums[left]==nums[left+1]) {
							left++;
						}
						while (left<rigth && nums[rigth]==nums[rigth-1] ) {
							rigth--;
						}
						left++;
						rigth--;
					}
					
				}
			}
			
		}
       return list; 
    }
}
```

![image-20220121193806281](https://gitee.com/dong2645981073/picture-summary/raw/master//image/image-20220121193806281.png)案例思考：

### 10.总结

+ 数组：2，7
+ set：3，4
+ map：5，6
+ 双指针：8，9

## 四.字符串

### 1.[ 反转字符串](https://leetcode-cn.com/problems/reverse-string/)

```java
class Solution {
    public void reverseString(char[] s) {
        for (int i = 0; i < s.length/2; i++) {
			char temp;
			temp=s[i];
			s[i]=s[s.length-1-i];
			s[s.length-1-i]=temp;
		}
    }
}
```

### 2.[反转字符串 II](https://leetcode-cn.com/problems/reverse-string-ii/)

我的，太复杂了 不好

```java
class Solution {
    public String reverseStr(String s, int k) {
        char[] chars=s.toCharArray();
        for (int i = 0; i < chars.length; i+=2*k) {
        	if (i+k>chars.length-1) {
        		for (int l = i,r=chars.length-1; l < i+((chars.length-i)/2); l++,r--) {
    				char temp=chars[l];
    				chars[l]=chars[r];
    				chars[r]=temp;
    			}
        		break;
            }
			for (int l = i,r=i-1+k; l <i+k/2 ; l++,r--) {
				char temp=chars[l];
				chars[l]=chars[r];
				chars[r]=temp;
				
			}
			
		}
        return new String(chars);
      
    }
}
```

```java
class Solution {
    public String reverseStr(String s, int k) {
        char[] ch = s.toCharArray();
        // 1. 每隔 2k 个字符的前 k 个字符进行反转
        for (int i = 0; i< ch.length; i += 2 * k) {
            // 2. 剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符 或正常情况。 
            if (i + k <= ch.length) {
                reverse(ch, i, i + k -1);
                continue;
            }
            // 3. 剩余字符少于 k 个，则将剩余字符全部反转
            reverse(ch, i, ch.length - 1);
        }
        return  new String(ch);

    }
    // 定义翻转函数
    public void reverse(char[] ch, int i, int j) {
    for (; i < j; i++, j--) {
        char temp  = ch[i];
        ch[i] = ch[j];
        ch[j] = temp;
    }

    }
}
```



### 3.[剑指 Offer 05. 替换空格](https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/)

```java
//瞎搞
class Solution {
    public String replaceSpace(String s) {
		return s.replace(" ", "%20");
    }
}
```

**很多数组填充类的问题，都可以先预先给数组扩容带填充后的大小，然后在从后向前进行操作。**

java字符串长度增加原理（体外话：本质，通过StringBuilder走中间过程，通过append方法实现）：String1=String1+String2; 

```java
class Solution {
    public String replaceSpace(String s) {
		//StringBuffer是线程安全的，而StringBuilder则没有实现线程安全功能，所以性能略高。
		StringBuilder sb = new StringBuilder();
		char[] chars = s.toCharArray();
		int l= s.length(); //原来的长度
		for (int i = 0; i < chars.length; i++) {
			if (chars[i] == ' ') {
				sb.append("  ");
			}
		}
		if (sb.length() == 0 || s == null || s.length() == 0) {
			return s;
		}
		s+=sb.toString();
		chars = s.toCharArray();
		int left=l-1;
		int rigth=chars.length-1;
		for (int i =l-1 ; i >= 0; i--) {
			if (chars[i] ==' ') {
				chars[rigth--]='0';
				chars[rigth--]='2';
				chars[rigth]='%';
			}else {
				chars[rigth]=chars[left];
			}
			rigth--;
			left--;
		}
	return new String(chars);
    }
}
```

```java

class Solution {
    public String replaceSpace(String s) {
		//StringBuffer是线程安全的，而StringBuilder则没有实现线程安全功能，所以性能略高。
		StringBuilder sb = new StringBuilder();
		char[] chars = s.toCharArray();
		int l= s.length();
		for (int i = 0; i < chars.length; i++) {
			if (chars[i] == ' ') {
                sb.append("  ");
			}
		}
		if (sb.length() == 0 || s == null || s.length() == 0) {
			return s;
		}
		s+=sb.toString();
		chars = s.toCharArray();
		int left=l-1;
		int rigth=chars.length-1;
		while(left>=0) {
			if (chars[left] ==' ') {
				chars[rigth--]='0';
				chars[rigth--]='2';
				chars[rigth]='%';
			}else {
				chars[rigth]=chars[left];
			}
			rigth--;
			left--;
		}
	return new String(chars);
    }
}

```

### 4.[翻转字符串里的单词](https://leetcode-cn.com/problems/reverse-words-in-a-string/)

```java
class Solution {
    public String reverseWords(String s) {
		//trim()的作用是去掉字符串两端的多余的空格
		s = s.trim();
		String[] ss = s.split(" ");
		s=new String(); 
		for (int i = ss.length-1; i>=0; i--) {
			//空格大量存在时 有的元素是空的。
			if (!ss[i].equals("")) {
				s+=ss[i];
                System.out.println(s);
			}
			if(!ss[i].equals("") && i != 0){
                s+=" ";
                System.out.println(s);
            }
		}
		return s;
    }
}
```

```java
class Solution {
   /**
     * 不使用Java内置方法实现
     * 1.去除首尾以及中间多余空格
     * 2.反转整个字符串
     * 3.反转各个单词
     */
    public String reverseWords(String s) {
        // System.out.println("ReverseWords.reverseWords2() called with: s = [" + s + "]");
        // 1.去除首尾以及中间多余空格
        StringBuilder sb = removeSpace(s);
        // 2.反转整个字符串
        reverseString(sb, 0, sb.length() - 1);
        // 3.反转各个单词
        reverseEachWord(sb);
        return sb.toString();
    }

    private StringBuilder removeSpace(String s) {
        // System.out.println("ReverseWords.removeSpace() called with: s = [" + s + "]");
        int start = 0;
        int end = s.length() - 1;
        while (s.charAt(start) == ' ') start++;
        while (s.charAt(end) == ' ') end--;
        StringBuilder sb = new StringBuilder();
        while (start <= end) {
            char c = s.charAt(start);
            if (c != ' ' || sb.charAt(sb.length() - 1) != ' ') {
                sb.append(c);
            }
            start++;
        }
        // System.out.println("ReverseWords.removeSpace returned: sb = [" + sb + "]");
        return sb;
    }

    /**
     * 反转字符串指定区间[start, end]的字符
     */
    public void reverseString(StringBuilder sb, int start, int end) {
        // System.out.println("ReverseWords.reverseString() called with: sb = [" + sb + "], start = [" + start + "], end = [" + end + "]");
        while (start < end) {
            char temp = sb.charAt(start);
            sb.setCharAt(start, sb.charAt(end));
            sb.setCharAt(end, temp);
            start++;
            end--;
        }
        // System.out.println("ReverseWords.reverseString returned: sb = [" + sb + "]");
    }

    private void reverseEachWord(StringBuilder sb) {
        int start = 0;
        int end = 1;
        int n = sb.length();
        while (start < n) {
            while (end < n && sb.charAt(end) != ' ') {
                end++;
            }
            reverseString(sb, start, end - 1);
            start = end + 1;
            end = start + 1;
        }
    }
}
```

### 5.[剑指 Offer 58 - II. 左旋转字符串](https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/)

```jav
class Solution {
    public String reverseLeftWords(String s, int n) {
		StringBuilder sBuilder =new StringBuilder();
		
		for (int i = n; i < s.length(); i++) {
			sBuilder.append(s.charAt(i));
		}
		for(int i = 0;i<n;i++) {
			sBuilder.append(s.charAt(i));
		}
		return sBuilder.toString();		
    }
}
```

### 6.KMP

+ 前缀：包含第一个 不包含最后一个 的所有子串（有多个
+ 后缀
+ 最长相等前后缀 eg：![image-20220124213751578](https://gitee.com/dong2645981073/picture-summary/raw/master//image/image-20220124213751578.png)

那么模式串 aabaaf 的前缀表（那么也就是next数组）是0 1 0 1 2 0

求next数组代码:

```java
void getNext(int* next, const string& s){
    int j = -1;
    next[0] = j;
    for(int i = 1; i < s.size(); i++) { // 注意i从1开始
        while (j >= 0 && s[i] != s[j + 1]) { // 前后缀不相同了
            j = next[j]; // 向前回退
        }
        if (s[i] == s[j + 1]) { // 找到相同的前后缀
            j++;
        }
        next[i] = j; // 将j（前缀的长度）赋给next[i]
    }
}

 public void getNext(int[] next, String s){
        int j = -1;
        next[0] = j;
        for (int i = 1; i<s.length(); i++){
            while(j>=0 && s.charAt(i) != s.charAt(j+1)){
                j=next[j];
            }

            if(s.charAt(i)==s.charAt(j+1)){
                j++;
            }
            next[i] = j;
        }
    }
```

求next数组：1.初始化，2循环i，3. 不相同循环回退 相同j++  最后赋值

```java
class Solution {
    public int strStr(String haystack, String needle) {
		if (needle.length() == 0) {
            return 0;
        }
		
		int[] next=new int[needle.length()];
		getNext(next, needle);
		int j=-1;
		for (int i = 0; i < haystack.length(); i++) {
			while(j>=0&& haystack.charAt(i) != needle.charAt(j+1)) {
				j=next[j];
			}
			if(haystack.charAt(i)==needle.charAt(j+1)){
                j++;
            }
			if (j==needle.length()-1) {
				return (i-needle.length()+1);
			}
		}
		return -1;
    }
	public void getNext(int[] next,  String s) {
		int j=-1;
		next[0]=j;
		for(int i = 1 ;i<s.length();i++) {
			while(j>=0&&s.charAt(i)!=s.charAt(j+1)) {
				j=next[j];
			}
			if (s.charAt(i)==s.charAt(j+1)) {
				j++;
			}
			next[i]=j;
		}
	}
}
```

```java
  public int strStr(String haystack, String needle) {
        int m = needle.length();
        // 当 needle 是空字符串时我们应当返回 0
        if (m == 0) {
            return 0;
        }
        int n = haystack.length();
        if (n < m) {
            return -1;
        }
        int i = 0;
        int j = 0;
        while (i < n - m + 1) {
            // 找到首字母相等
            while (i < n && haystack.charAt(i) != needle.charAt(j)) {
                i++;
            }
            if (i == n) {// 没有首字母相等的
                return -1;
            }
            // 遍历后续字符，判断是否相等
            i++;
            j++;
            while (i < n && j < m && haystack.charAt(i) == needle.charAt(j)) {
                i++;
                j++;
            }
            if (j == m) {// 找到
                return i - j;
            } else {// 未找到
                i -= j - 1;
                j = 0;
            }
        }
        return -1;
    }
```

## 五.栈与队列

### 1.理论

```java
public static void main(String[] args) {
    //队列和栈 都可以用它
		Deque<Integer> deque = new ArrayDeque<Integer>(); 
    
		deque.add(1);
		deque.add(2);
		deque.add(3);
    //	相当于 1 2 3
		
		deque.addFirst(4); 4 1 2 3
		int i =deque.getFirst(); 4
		System.out.println(i);
		 i =deque.getLast(); 3
		System.out.println(i);
		
		 i =deque.removeLast();3
		System.out.println(i);
		 i =deque.getLast();2
		System.out.println(i);
	}
4
3
3
2
```

### 2.[用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks/)

```java
class MyQueue {
   	Deque<Integer> stack_in = new ArrayDeque<Integer>();
	Deque<Integer> stack_out = new ArrayDeque<Integer>();
	public MyQueue() {

    }
    
    public void push(int x) {
    	stack_in.addFirst(x);
    }
    
    public int pop() {
    	//一个空的队列不会调用 pop 或者 peek 操作
    	if (stack_out.isEmpty()) {
			while(!stack_in.isEmpty()) {
				stack_out.addFirst(stack_in.removeFirst());
			}
			return stack_out.removeFirst();
		}else {
			return stack_out.removeFirst();
		}
    }
    
    public int peek() {
    	if (stack_out.isEmpty()) {
			while(!stack_in.isEmpty()) {
				stack_out.addFirst(stack_in.removeFirst());
			}
			return stack_out.getFirst();
		}else {
			return stack_out.getFirst();
		}
    }
    
    
    public boolean empty() {
    	return stack_in.isEmpty()&& stack_out.isEmpty();
    }
}

```

### 3.[用队列实现栈](https://leetcode-cn.com/problems/implement-stack-using-queues/)

```java
Deque<Integer> deque = new ArrayDeque<Integer>();
	 	public MyStack() {

	    }
	    
	    public void push(int x) {
	    	deque.addLast(x);
	    }
	    
	    public int pop() {
	    	for (int i = 0; i < deque.size()-1 ; i++) {
				deque.addLast(deque.removeFirst());
			}
	    	return deque.removeFirst();
	    	
	    }
	    
	    public int top() {
	    	
	    	return deque.getLast();
	    }
	    
	    public boolean empty() {
	    	return deque.isEmpty();
	    }
```

### 4.[有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)

```java
class Solution {
        public boolean isValid(String s) {
            Stack<Character> stack = new Stack<>();
            char[] chars = s.toCharArray();
            for (char c : chars) {
                if(c=='('||c== '{'||c=='['){
                    stack.push(c);
                }else {
                    if(stack.empty()) return false;
                    if (c==')'&& stack.pop()!='(') return false;
                    if (c=='}'&& stack.pop()!='{') return false;
                    if (c==']'&& stack.pop()!='[') return false;
                    
                }
            }
            return stack.empty();
        }
    }
```

### 5.[删除字符串中的所有相邻重复项](https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string/)

```java
class Solution {
    public String removeDuplicates(String s) {
		Deque<Character> deque =new ArrayDeque<Character>();
		StringBuffer stringBuffer = new StringBuffer();
		for(int i = 0; i<s.length();i++) {
			if (deque.isEmpty()) {
				deque.add(s.charAt(i));
			}else {
				if (deque.getFirst() != s.charAt(i)) {
					deque.addFirst(s.charAt(i));
				}else {
					deque.removeFirst();
				}
			}
			
		}
		for (int i = deque.size(); i >0; i--) {
			stringBuffer.append(deque.removeLast());
		}
		return stringBuffer.toString();
    }
}
```

### 6.[逆波兰表达式求值](https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/)

```java
class Solution {
    public static int evalRPN(String[] tokens) {
        Deque<String> deque = new ArrayDeque<String>();
        for (int i = 0; i < tokens.length; i++) {
			if (tokens[i].equals("+") || tokens[i].equals("-") || 
					tokens[i].equals("*") || tokens[i].equals("/")) {
				int num=0;
				int a = Integer.parseInt(deque.removeFirst());
				int b = Integer.parseInt(deque.removeFirst());
				if (tokens[i].equals("+")) {
					num=b+a;
				}else if (tokens[i].equals("-")) {
					num=b-a;
				}else if (tokens[i].equals("*") ) {
					num=b*a;
				}else if (tokens[i].equals("/")) {
					//这里要注意 不是a/b哦
					num=b/a;
				}
				deque.addFirst(String.valueOf(num));
			}else {
				deque.addFirst(tokens[i]);
			}
		}
        return Integer.parseInt(deque.getFirst());
    }
}
```

### 7.[滑动窗口最大值](https://leetcode-cn.com/problems/sliding-window-maximum/)

```java
class Solution {
   public int[] maxSlidingWindow(int[] nums, int k) {
	      Deque<Integer> deque =new ArrayDeque<Integer>(); 
	      int[] res = new int[nums.length-k+1]; //一共窗口的次数
       
		
	      for (int right = 0; right < nums.length; right++) {
              //进入队列
            // 如果队列不为空且当前考察元素大于等于队尾元素，则将队尾元素移除。
            // 直到，队列为空或当前考察元素小于新的队尾元素
			while(!deque.isEmpty()&& nums[right]>=nums[deque.getLast()]) {
				deque.removeLast();
				
			}
			 // 存储元素下标
			deque.addLast(right);
			
			int left = right - k +1;
            // 当队首元素的下标小于滑动窗口左侧边界left时
            // 表示队首元素已经不再滑动窗口内，因此将其从队首移除 
            if (deque.getFirst() < left) {
            	deque.removeFirst();
            }
            // 由于数组下标从0开始，因此当窗口右边界right+1大于等于窗口大小k时
            // 意味着窗口形成。此时，队首元素就是该窗口内的最大值
            if (right +1 >= k) {
                res[left] = nums[deque.getFirst()];
            }

		}
	      return res;
	}
}
```

### 8.[前 K 个高频元素](https://leetcode-cn.com/problems/top-k-frequent-elements/)

先用map统计 然后用优先队列统计前K个大的。  重点：优先队列统计前K个大 

```java
public int[] topKFrequent(int[] nums, int k) {
		Map<Integer,Integer> map =new HashMap<Integer, Integer>();
		for (int i = 0; i < nums.length; i++) {
			if (map.containsKey(nums[i])) {
				map.put(nums[i], map.get(nums[i])+1);
			}else {
				map.put(nums[i], 1);
			}
		}
		PriorityQueue<Integer> queue =new PriorityQueue<Integer>(new Comparator<Integer>() {

			@Override
			public int compare(Integer o1, Integer o2) {
				// TODO Auto-generated method stub
				return map.get(o1)-map.get(o2);
			}
		});
		for (Integer key : map.keySet()) {
			if (queue.size()<k) {
				queue.add(key);
			}else if (map.get(queue.peek())<map.get(key)) {
				queue.remove();
				queue.add(key);

			}
		}
		int[] res =new int[k];
		for (int i = 0; i < k; i++) {
			res[i]=queue.remove();
		}
		return res;
    }
```

**优先级队列PriorityQueue**

我们都知道队列，队列的核心思想就是先进先出，这个优先级队列有点不太一样。优先级队列中，数据按关键词有序排列，插入新数据的时候，会自动插入到合适的位置保证队列有序。（顺序有两种形式：升序或者是降序）

优先级队列底层的数据结构其实是一颗二叉堆（一个完全二叉树）

## 六.二叉树

### 1. 二叉树的递归遍历

**递归算法**的学习_**三要素**

> 1. **确定递归函数的参数和返回值：** 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。
> 2. **确定终止条件：** 写完了递归算法,  运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。
> 3. **确定单层递归的逻辑：** 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。

递归算法：前序遍历二叉树

>+ 顺序是 中->左->右
>+ 函数的参数应该是 一个指向结点的指针 
>+ 终止条件是应该是 指针指向的结点为null 也就是没有子结点了
>+ 单层递归的逻辑应该是 先输出中结点，再让左结点进入递归函数，再让右结点进入递归函数

```java
class Solution {
      public List<Integer> preorderTraversal(TreeNode root) {
        ArrayList<Integer> result = new ArrayList<>();
        preorder(result,root);
        return result;
    }
    public  List preorder(List list,TreeNode treeNode){
        if(treeNode == null){
            return list;
        }
        list.add(treeNode.val);
        preorder(list,treeNode.left);
        preorder(list,treeNode.right);
        return list;
    }
}
```

中序，后序。改变代码顺序即可

### 2. 二叉树迭代遍历（正常迭代法）

使用到了栈，根据规律处理

> 前序遍历顺序：中-左-右，入栈顺序：中-右-左
>
> 中序遍历顺序: 左-中-右 入栈顺序： 左-右
>
> 后序遍历顺序 左-右-中 入栈顺序：中-左-右 出栈顺序：中-右-左， 最后翻转结果

```java
 //这里我使用了deque实现栈
Deque<Integer> deque = new ArrayDeque<Integer>(); 
```

```java
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        ArrayList<Integer> result = new ArrayList<>();
        Deque<TreeNode> stack_deque = new ArrayDeque<>();
        if(root == null){
            return result;
        }
        stack_deque.addFirst(root);
        while (!stack_deque.isEmpty()) {
            TreeNode node = stack_deque.removeFirst();
            result.add(node.val);
            if (node.right != null){
                stack_deque.addFirst(node.right);
            }
            if (node.left != null){
                stack_deque.addFirst(node.left);
            }
        }
        return result;
    }
}
```

中序 不好理解 最好在纸上画一下

**在使用迭代法写中序遍历，就需要借用指针的遍历来帮助访问节点，栈则用来处理节点上的元素**，前序和后序都是对取出来的同时进行处理和遍历

```java
class Solution {
   public List<Integer> inorderTraversal(TreeNode root) {
        ArrayList<Integer> result = new ArrayList<>();
        Deque<TreeNode> stack =new ArrayDeque<>();
        if (root == null){
            return result;
        }
        TreeNode cur = root;
        while (cur != null || !stack.isEmpty()){
            if (cur !=null){
                stack.addFirst(cur);
                cur = cur.left;
            }else {
                cur = stack.removeFirst();
                result.add(cur.val);
                cur=cur.right;
            }
        }
        return result;
    }
}
```

后序 是在前序的基上调整代码  然后再翻转list

![image-20220306142530372](https://s2.loli.net/2022/05/02/Yvwa5eXUMVPtJxW.png)

在写代码时 入栈的顺序 是左 右，出栈进list是中 右 左，一个reverse

最后 结果刚好是左右中

```java
class Solution {
     public List<Integer> postorderTraversal(TreeNode root) {
        ArrayList<Integer> result = new ArrayList<>();
        Deque<TreeNode> stack = new ArrayDeque<>();
        if (root == null){
            return result;
        }
        stack.addFirst(root);
        while(!stack.isEmpty()){
            TreeNode cur = stack.removeFirst();
            result.add(cur.val);
            if (cur.left != null){
                stack.addFirst(cur.left);
            }
            if (cur.right != null){
                stack.addFirst(cur.right);
            }
        }
        Collections.reverse(result);
        return  result;
    }
}
```

### 3. 二叉树迭代遍历（统一迭代法）

通过空节点来标记，~~面试直接写这种感觉很难，没太看~~

```java
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> result = new LinkedList<>();
        Stack<TreeNode> st = new Stack<>();
        if (root != null) st.push(root);
        while (!st.empty()) {
            TreeNode node = st.peek();
            if (node != null) {
                st.pop(); // 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中
                if (node.right!=null) st.push(node.right);  // 添加右节点（空节点不入栈）
                if (node.left!=null) st.push(node.left);    // 添加左节点（空节点不入栈）
                st.push(node);                          // 添加中节点
                st.push(null); // 中节点访问过，但是还没有处理，加入空节点做为标记。
                
            } else { // 只有遇到空节点的时候，才将下一个节点放进结果集
                st.pop();           // 将空节点弹出
                node = st.peek();    // 重新取出栈中元素
                st.pop();
                result.add(node.val); // 加入到结果集
            }
        }
        return result;
    }
}
```

```java
class Solution {
public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> result = new LinkedList<>();
    Stack<TreeNode> st = new Stack<>();
    if (root != null) st.push(root);
    while (!st.empty()) {
        TreeNode node = st.peek();
        if (node != null) {
            st.pop(); // 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中
            if (node.right!=null) st.push(node.right);  // 添加右节点（空节点不入栈）
            st.push(node);                          // 添加中节点
            st.push(null); // 中节点访问过，但是还没有处理，加入空节点做为标记。

            if (node.left!=null) st.push(node.left);    // 添加左节点（空节点不入栈）
        } else { // 只有遇到空节点的时候，才将下一个节点放进结果集
            st.pop();           // 将空节点弹出
            node = st.peek();    // 重新取出栈中元素
            st.pop();
            result.add(node.val); // 加入到结果集
        }
    }
    return result;
}
}
```

```java
class Solution {
   public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> result = new LinkedList<>();
        Stack<TreeNode> st = new Stack<>();
        if (root != null) st.push(root);
        while (!st.empty()) {
            TreeNode node = st.peek();
            if (node != null) {
                st.pop(); // 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中
                st.push(node);                          // 添加中节点
                st.push(null); // 中节点访问过，但是还没有处理，加入空节点做为标记。
                if (node.right!=null) st.push(node.right);  // 添加右节点（空节点不入栈）
                if (node.left!=null) st.push(node.left);    // 添加左节点（空节点不入栈）         
                               
            } else { // 只有遇到空节点的时候，才将下一个节点放进结果集
                st.pop();           // 将空节点弹出
                node = st.peek();    // 重新取出栈中元素
                st.pop();
                result.add(node.val); // 加入到结果集
            }
        }
        return result;
   }
}
```

### 4.二叉树层序遍历

#### [102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

![image-20220503131243036](https://s2.loli.net/2022/05/03/kMoPHqEaSXL4bsx.png)

BFS 广度遍历：迭代。利用队列一层一层处理

```java
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> re = new ArrayList<>();
        ArrayDeque<TreeNode> queue = new ArrayDeque<>();
        if (root == null) return re;
        queue.addFirst(root);
        while (!queue.isEmpty()) {
            ArrayList<Integer> arraylist = new ArrayList<>();

            int n = queue.size();//这个长度反应出来的是每一层的个数
            // 对这层的每一个进行处理，先进队的先处理，处理就是放值和放子节点
            for (int i = 0; i < n; i++) {
                root = queue.removeLast();
                arraylist.add(root.val);
                if(root.left!=null) queue.addFirst(root.left);
                if(root.right!=null) queue.addFirst(root.right);
            }
            //处理完一层后放到大list里
            re.add(arraylist);
        }
        return re;
    }
}
```

DFS 深度优先遍历实现层序遍历  递归法

```java
class Solution {
    public static List<List<Integer>> re = new ArrayList<List<Integer>>();
    public List<List<Integer>> levelOrder(TreeNode root) {
        re=new ArrayList<List<Integer>>(); //力扣必须写这一下，要不然静态变量不更新，默认是一个Solution类在跑所有测试点
        Order(root,0);
        return re;
    }
    public static void Order(TreeNode node,int deep){
        if (node==null) return;
        //每个节点进来先deep++ 传入的deep是父节点的所在层数
        deep++;
        if (re.size()<deep){//一个size是一层，如果节点所在木有创建层，先创建这一层放进去
            ArrayList<Integer> arrayList = new ArrayList<>();
            re.add(arrayList);
        }
        //取出这个节点对于的这一层
        List<Integer> curCheng = re.get(deep - 1);
        curCheng.add(node.val);
        Order(node.left,deep);
        Order(node.right,deep);

    }
}
```

#### 107.二叉树的层次遍历II

基于上一个题目

```java
 List<List<Integer>> reQ= new ArrayList<>();
    for (int i=re.size();i>0;i--) {
                reQ.add(re.get(i-1));
     }
        return reQ;
```

#### 199.二叉树的右视图

```java
class Solution {
    public List<Integer> rightSideView(TreeNode root) {
            List<Integer> re = new ArrayList<>();
        ArrayDeque<TreeNode> queue = new ArrayDeque<>();
        if (root == null) return re;
        queue.addFirst(root);
        while (!queue.isEmpty()) {
            int n = queue.size();//这个长度反应出来的是每一层的个数
            // 对这层的每一个进行处理，先进队的先处理，处理就是放值和放子节点
             for (int i = 0; i < n; i++) {
                root = queue.removeLast();
               //判断
                if(i==n-1){
                    re.add(root.val);
                }
                if(root.left!=null) queue.addFirst(root.left);
                if(root.right!=null) queue.addFirst(root.right);
            }
        

        }
        return re;
    }
}
```

正常一层一层遍历的基础上，判断是不是现在层的最后一个，如果是最后一个再加进去。因为有时候是看到左有时候是看到右，只能保证是每层的最后一个。

#### 637.二叉树的层平均值

```java
public List<Double> averageOfLevels(TreeNode root) {
    ArrayDeque<TreeNode> queue = new ArrayDeque<>();
    List<Double> re = new ArrayList<>();
    if (root==null) return re;
    queue.addFirst(root);
    while (!queue.isEmpty()){
        int size = queue.size();
        Double sum=0.0;
        for (int i=0;i<size;i++){
            TreeNode node = queue.removeLast();
            sum+=node.val;
            if (node.left!=null) queue.addFirst(node.left);
            if (node.right!=null) queue.addFirst(node.right);
        }
        double avg=sum/size;
        re.add(avg);
    }
    return re;
}
```

#### 429.N叉树的层序遍历

```java
class Solution {
    public List<List<Integer>> levelOrder(Node root) {
        List<List<Integer>> re = new ArrayList<>();
        if(root==null){
            return re;
        }
        ArrayDeque<Node> queue = new ArrayDeque<Node>();
        
        queue.add(root);
        while(!queue.isEmpty()){
            int n = queue.size();
            ArrayList<Integer> list = new ArrayList<>();
            for (int i =0; i<n;i++){
                Node node = queue.removeLast();
                list.add(node.val);
                for (Node child : node.children) {
                    if (child!=null){
                        queue.addFirst(child);
                    }
                }
            }
            re.add(list);
        }
        return  re;
    }
}
```

#### 515.在每个树行中找最大值

```java
class Solution {
    public List<Integer> largestValues(TreeNode root) {
        ArrayList<Integer> re = new ArrayList<>();
        ArrayDeque<TreeNode> queue = new ArrayDeque<>();
        if (root==null){
            return  re;
        }
        queue.add(root);
        while (!queue.isEmpty()){
            int n = queue.size();
            int max=Integer.MIN_VALUE;
            for (int i = 0; i < n; i++) {
                TreeNode node = queue.removeLast();
                max =Math.max(max,node.val);
                if (node.left!=null) queue.addFirst(node.left);
                if (node.right!=null) queue.addFirst(node.right);
            }
            re.add(max);
        }
       return  re;

    }
}
```



- 116.填充每个节点的下一个右侧节点指针
- 117.填充每个节点的下一个右侧节点指针II
- 104.二叉树的最大深度
- 111.二叉树的最小深度
